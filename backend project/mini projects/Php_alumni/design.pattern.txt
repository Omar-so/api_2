Singleton Pattern — Database Connection
Purpose:
Ensure that only one instance of the database connection exists throughout the application lifecycle.

Where Applied:
In config/database.php or wherever you manage DB connection.

Why Used:
Avoids multiple connections and ensures consistency in DB operations.

class Database {
    private static $instance = null;
    private $conn;

    private function __construct() {
        $this->conn = new PDO("mysql:host=localhost;dbname=alumni", "root", "");
    }

    public static function getInstance() {
        if (self::$instance == null) {
            self::$instance = new Database();
        }
        return self::$instance->conn;
    }
}
 Facade Pattern — Email Sending
Purpose:
Provides a simplified interface (MailSender) to an underlying complex email-sending system (PHPMailer or mail()).

Where Applied:
In emailsender.php.

Why Used:
Hides complexity from the controller. Controllers call MailSender::send() instead of writing email headers or handling SMTP logic directly.

Code Snippet Example:


class MailSender {
    public static function send($to, $subject, $body) {
        // internally uses PHPMailer or mail()
    }
}


Facade Pattern — APIfacade
Purpose:
The Builder Pattern is used to construct complex objects step by step. It separates the construction of an object from its representation, allowing you to create different types or variations of objects using the same building process.


Where Applied:
In Facade.js

Why Used:
Cleaner Code: It simplifies object creation, especially when there are many fields or optional properties.


Code Snippet Example:

class APIFacade {
    constructor({ baseurl } = {}) {
        this.baseUrl = baseurl || "http://localhost:8000/index.php?action=";
    }
}